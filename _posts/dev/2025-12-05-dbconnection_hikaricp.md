---
layout: post
title: "DB Connection & HikariCP"
subtitle: "DB Connection & JPA 설정 가이드 (HikariCP / Spring Boot)"
date: 2025-12-05
author: kgi0412
# cover-img: /assets/img/
# thumbnail-img: /assets/img/posts/
# share-img: /assets/img/
categories: [wiki, dev]
tags: [ChatGPT, springboot, HikariCP, DBConnection]
language: ko
comments: true
---

## 1. HikariCP (Connection Pool) 설정 및 전략 🛡️

우리는 성능과 안정성 측면에서 검증된 **HikariCP**를 사용하며, 다음 설정을 통해 커넥션 누수와 부하를 방지합니다.

| 설정 항목 | 현재 값 | 의미 | 설정 배경 및 전략 (Why?) |
| :--- | :--- | :--- | :--- |
| `pool-name` | `HikariPool-Prod` | 커넥션 풀을 식별하기 위한 이름입니다. | 운영 환경에서 로그를 확인할 때 **어떤 풀**에서 문제가 발생했는지 빠르게 파악하기 위함입니다. |
| `auto-commit` | `true` | SQL 작업 완료 후 DB에 자동 커밋을 시도할지 여부입니다. | **Spring Transaction Manager가 트랜잭션을 완전히 관리**하도록 하기 위해 `true`로 설정합니다. |
| `connection-timeout` | 20000ms (20초) | 풀이 고갈되었을 때, 새 커넥션을 얻기 위해 최대로 대기하는 시간입니다. | **서버 눈사태(Snowball Effect) 방지**가 주 목적입니다. 풀 고갈 시 즉시 실패하는 대신, 20초 동안 대기하여 해소 기회를 줍니다. |
| **`validation-timeout`** | **1000ms (1초)** | 유효성 검사 메서드가 응답하기를 기다리는 최대 시간입니다. | **[전략] 빠른 실패(Fail-Fast)와 안정성 간의 상충 관계**를 고려한 절충안입니다. (상세 설명: **1-2절**) |
| **`leak-detection-threshold`** | **0 (비활성화)** | 커넥션이 반환되지 않고 풀 밖에서 일정 시간 머무를 때 경고 로그를 출력합니다. | **[전략]** 운영 환경 성능 최적화를 위해 **`0`으로 비활성화**합니다. 개발 환경에서는 누수 탐지를 위해 **3000ms로 활성화**합니다 (상세 설명: **1-3절**). |
| `maximum-pool-size` | 40 | 풀이 가질 수 있는 최대 커넥션 수입니다. | **동시 접속자 수, 애플리케이션 서버 코어 수, DB 성능**을 고려하여 설정한 값입니다. |
| `minimum-idle` | 5 | 풀에서 최소한으로 유지할 유휴(`Idle`) 커넥션 수입니다. | 갑작스러운 요청에도 **즉시 사용할 수 있는 커넥션**을 확보하여 지연 시간을 줄입니다. |
| **`idle-timeout`** | **600000ms (10분)** | 유휴 상태인 커넥션이 풀에 남아있을 수 있는 최대 시간입니다. | **[전략] 유휴 리소스 정리와 풀 안정성 간의 균형점**을 찾은 표준 값입니다. (상세 설명: **1-4절**) |
| `max-lifetime` | 1740000ms (29분) | 커넥션이 풀에서 존재할 수 있는 최대 수명입니다. | **DB/방화벽의 세션 타임아웃** 전에 미리 커넥션을 안전하게 교체하여 오류를 방지하는 모범 사례입니다. |
| **`connection-test-query`** | **제거/주석 처리** | 커넥션 유효성을 검사하는 쿼리입니다. | **[최적화 반영]** **JDBC 4.0 이상 드라이버**가 지원하는 **`Connection.isValid()`** 메서드가 SQL 실행보다 훨씬 효율적이므로, 해당 메서드가 사용되도록 **제거(주석 처리)**했습니다. |

---

### 1-1. 🔍 연결 유효성 검사 방식 심화 설명

* **최신 방식 (권장):** **JDBC 4.0 이상 드라이버**를 사용할 경우, `Connection.isValid(timeout)` 메서드는 SQL 쿼리 실행 없이 **드라이버 네이티브 코드**를 통해 빠르게 연결 유효성을 검사하여 **성능상 우위**에 있습니다.
* **Legacy 방식:** `connection-test-query`를 명시하면 DB에 쿼리를 실제로 실행해야 하므로, 네트워크 왕복 및 DB 부하가 발생합니다. 우리는 최신 드라이버의 효율적인 방식을 선택했습니다.

---

### 1-2. ⚖️ `validation-timeout` 값 선정 배경 (1초 전략)

`validation-timeout` 설정은 **'빠른 실패(Fail-Fast)'**와 **'일시적 지연 회복(Resilience)'** 중 어느 쪽에 가중치를 둘 것인지 결정하는 **상충 관계(Trade-off)**의 문제입니다.

| 관점 | 선호 타임아웃 | 선택 시 고려 사항 |
| :--- | :--- | :--- |
| **빠른 실패 (Fail-Fast)** | **1초 이하** | **서비스 응답 속도 안정성 최우선.** 죽은 커넥션에 묶여 불필요한 장기 지연이 발생하는 것을 방지합니다. |
| **안정성 및 회복 (Resilience)** | **3초 ~ 5초** | **일시적인 DB/네트워크 부하 허용.** 정상 커넥션이 잠깐의 지연 때문에 버려지는 오버헤드를 줄입니다. |

**결론:** 현재 우리의 서비스는 **응답 속도 안정성**을 중요 목표로 설정했습니다. $1$초를 초과하는 지연은 문제 발생 가능성이 높다고 판단하여, 불필요한 장기 대기보다는 **빠른 실패 처리**를 통해 전체 시스템의 안정적인 응답 속도 궤도를 유지하는 방식을 선택했습니다.

---

### 1-3. 🛠️ `leak-detection-threshold` 운영 전략 (개발/운영 분리)

| 환경 | 설정 값 (예시) | 운영 전략 | 이유 |
| :--- | :--- | :--- | :--- |
| **개발 (`dev`)** | **3000ms** (3초) | **경고 모드 (활성화)**. | 커넥션 누수를 **개발 단계에서 조기에 발견**하고 스택 트레이스를 통해 문제 코드를 정확히 짚어줍니다. |
| **운영 (`prod`)** | **0** (비활성화) | **성능 최적화 모드.** | 누수 감지 시 발생하는 **로그 I/O 및 스택 트레이스 생성 오버헤드**가 트래픽이 많은 운영 서버의 성능을 저하시킵니다. |

---

### 1-4. 💤 `idle-timeout` 상세 설명 및 핵심 관계

이 설정은 유휴 커넥션을 풀에서 정리하여 리소스를 확보하는 역할을 합니다. 현재 설정된 **$10$분**은 풀 안정성과 리소스 효율성을 동시에 고려한 적절한 값입니다.

#### A. 다른 핵심 설정과의 관계 (매우 중요)

| 관계 대상 | 관계 규칙 | 설정 의도 |
| :--- | :--- | :--- |
| **`max-lifetime` (29분)** | **`idle-timeout` < `max-lifetime`** | 유휴 커넥션이 DB/방화벽 타임아웃에 도달하기 전에 `idle-timeout`에 의해 **미리 안전하게 제거**되도록 보장합니다. |
| **`minimum-idle` (5개)** | 풀 사이즈 $\le$ **`minimum-idle`** | `idle-timeout`이 만료되어도, 풀의 커넥션 개수는 **최소한 5개**를 유지하도록 보장합니다. |

#### B. 결론

$10$분 동안 사용되지 않은 커넥션을 회수함으로써 불필요한 메모리 및 DB 세션 점유를 방지하고, 풀이 급격히 수축되는 것을 막는 **안정적인 균형점**을 유지합니다.

---

## 2. Spring JPA & Hibernate 설정

| 설정 항목 | 현재 값 | 의미 | 설정 배경 (Why?) |
| :--- | :--- | :--- | :--- |
| `open-in-view` | `false` | **Open-Session-In-View (OSIV)** 패턴 사용 여부입니다. | **핵심 안전장치 1 (커넥션 누수 방지).** HTTP 요청이 끝날 때까지 DB 세션(커넥션)을 물고 있는 것을 방지하여, 트랜잭션 종료 즉시 커넥션을 풀에 반환하도록 강제합니다. |
| `provider_disables_autocommit` | `false` | Hibernate가 커넥션의 `auto-commit` 설정을 임의로 변경하지 못하도록 합니다. | **핵심 안전장치 2.** HikariCP의 `auto-commit: true` 설정과 충돌하거나 예상치 못한 동작을 방지합니다. |
| `ddl-auto` | `validate` | 애플리케이션 시작 시 DB 스키마와 엔티티 간의 매핑을 확인하는 설정입니다. | **운영 환경 안전성 확보.** 스키마 불일치 시 서버 구동을 중단하고 경고합니다. `update`나 `create`를 사용하지 않아 **운영 DB의 데이터 손실 위험**을 완전히 차단합니다. |

---

## 3. 🚨 핵심 안전장치 요약 및 심층 설명

### 3-1. OSIV 끄기 (`open-in-view: false`)

| 핵심 내용 | 상세 설명 |
| :--- | :--- |
| **위험성** | **커넥션 점유 시간 증가**로 인해 동시 요청이 많아지면 **커넥션 풀 고갈 위험**이 커집니다. |
| **해결** | `false`로 설정하면 트랜잭션 종료 시점에 커넥션을 즉시 풀에 반환합니다. 이로써 **커넥션 점유 시간이 최소화**되어 풀 고갈 위험을 낮추고, REST API의 **응답 속도 안정성**을 확보합니다. |
| **비유** | DB 커넥션은 '**은행 대출 창구**'입니다. OSIV를 끄는 것은 업무가 끝나면 **즉시 창구를 비우고** 다음 고객에게 넘겨주어 풀 고갈 위험을 최소화하는 것입니다. |

### 3-2. Leak Detection (`leak-detection-threshold`)

| 핵심 내용 | 상세 설명 |
| :--- | :--- |
| **작동** | 설정된 시간(개발 환경에서는 3초)을 초과하여 커넥션이 풀 외부에 머무르면, HikariCP가 이를 누수로 판단하고 **경고 로그와 함께 전체 스택 트레이스**를 출력합니다. |
| **효과** | 스택 트레이스를 통해 **누수가 발생한 정확한 코드 라인**을 찾아낼 수 있어 디버깅 시간을 혁신적으로 단축시킵니다. |
| **비유** | 누수 감지는 '**택시 미반납 경고등**'입니다. 커넥션이 너무 오래 반납되지 않으면 경고등이 켜져 문제가 있는 위치를 알려줍니다. |

---

## 4. 🔗 참고 자료 및 권장 학습 자료

* **HikariCP 공식 GitHub Wiki**: HikariCP의 모든 설정 항목에 대한 공식 문서입니다.
    * `[https://github.com/brettwooldridge/HikariCP/wiki/Configuration](https://github.com/brettwooldridge/HikariCP/wiki/Configuration)`
* **Spring Boot 공식 문서 (Data Access)**: Spring Boot 환경에서 데이터 접근 및 트랜잭션 관리에 대한 공식 가이드입니다.
    * `[https://docs.spring.io/spring-boot/docs/current/reference/html/data.html](https://docs.spring-boot/docs/current/reference/html/data.html)`
* **JDBC 4.0+ 관련 자료**: `Connection.isValid()`의 작동 방식 및 효율성을 이해하는 데 도움이 됩니다.
    * (검색어: `JDBC Connection.isValid performance vs test query`)